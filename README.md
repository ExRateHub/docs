## 1. Введение

**1.1. Цели проекта**

* Предоставить REST-API для получения курсов фиатных и криптовалют с упором на СНГ-рынок.
* Обеспечить доступ к актуальным курсам «на сейчас» и к историческим данным за произвольные даты.

**1.2. Описание организации**
ExRateHub — инновационная компания, специализирующаяся на агрегации и распространении данных по курсам валют и криптовалют. Наша миссия — предоставить разработчикам и бизнесам простые интеграции для мгновенного доступа к точным и актуализированным финансовым данным. Мы ориентированы на рынок СНГ, но поддерживаем мировые фиатные и цифровые активы.
Ключевые ценности:

* **Надёжность**: гарантируем доступность и точность данных.
* **Гибкость**: широкие возможности кастомизации и масштабирования.
* **Прозрачность**: чёткая документация и открытые SLA.
* **Инновации**: постоянное расширение источников и сервисов для пользователей.

**1.3. Целевая аудитория и сценарии использования**

* Финтех-компании и банки СНГ, нуждающиеся в упрощённом доступе к курсам ЦБ и крупнейших банков.
* Разработчики сервисов и мобильных приложений, где требуется быстрый обмен фиат/крипто.
* BI-аналитики и отчётность на основе исторических трендов.

---

## 2. Общие требования

**2.1. Объём и границы системы**

* Сервис выдаёт только данные (курсы), без операций обмена или хранения средств.
* Поддержка фиатных валют (CBR, Сбербанк, ВТБ, MOEX) и криптовалют (Binance и др.).

**2.2. Основные термины и сокращения**

* **API-ключ** — токен для аутентификации.
* **Redis-кеш** — слой быстрого чтения актуальных курсов с TTL.
* **Provider** — код источника данных (CBR, MOEX, BINANCE и т. д.).
* **RateType** — тип курса (MID, BUY, SELL).
* **SLA** — целевой уровень доступности.

**2.3. Технологический стек и порядок разработки**

* **Язык и фреймворки**: Python 3.11+, Litestar для HTTP-сервисов, SQLAlchemy + Alembic для работы с PostgreSQL, Redis-Py для кеша.

* **Фоновые задачи**: Celery + Redis/RabbitMQ для периодического fetcher-а.

* **Контейнеризация**: Docker, Docker Compose для локальной среды, Helm-чарты для Kubernetes (дальнейший этап).

* **CI/CD (Continuous Integration / Continuous Deployment)**: практика автоматизации сборки, тестирования и доставки кода. С помощью CI системы (например, GitHub Actions) при каждом изменении в репозитории автоматически:

  * **CI (Continuous Integration)**: выполняют сборку, линтинг (Black, Flake8) и прогон тестов (pytest), чтобы гарантировать, что новые изменения не «ломают» существующий код.
  * **CD (Continuous Deployment)**: собирают Docker-образы и автоматически деплоят обновлённые сервисы на стадии staging или production (через Ansible/SSH), обеспечивая быструю и надёжную доставку.

* **Мониторинг и логирование**: Prometheus + Grafana, Loki, Sentry.

* **Биллинг и платежи**: Stripe API интеграция в Billing Service.

**Порядок разработки**:

1. **Настройка инфраструктуры**: репозиторий, CI/CD, Docker Compose (PostgreSQL, Redis, сервисы skeleton).
2. **Service-Fetcher**: реализация fetcher-а, интеграция с внешними API, запись в Redis/SQL.
3. **Auth Service**: CRUD для API-ключей, валидация, интеграция с Billing Service.
4. **History Service**: эндпоинты `/v1/history` и `/v1/history/range`, доступ к БД.
5. **API Gateway**: маршрутизация запросов, проверка ключей, rate-limit, проксирование к микросервисам.
6. **Billing Service**: выставление счетов, приём вебхуков оплаты, отчёты по использованию.
7. **Интеграция и тесты**: end-to-end тесты, нагрузочное тестирование.
8. **Документация**: генерация OpenAPI, написание примеров и гида.

### 2.4. Архитектура микросервисов. Архитектура микросервисов

Для обеспечения модульности и лёгкого масштабирования система разбивается на следующие сервисы:

1. **Service-Fetcher**

   * Обращается к внешним провайдерам (CBR, MOEX, Binance и др.) по расписанию.
   * Записывает актуальные курсы в Redis и историю в PostgreSQL.
2. **API Gateway**

* `GET /v1/rates` — список текущих курсов (параметры: `base`, `currencies[]`, `provider?`, `rateType?`).
* `GET /v1/rate` — курс одной валюты к другой (`from`, `to`, `provider?`, `rateType?`).
* `GET /v1/currencies` — список поддерживаемых валют и криптопар (без параметров).
* `GET /v1/providers` — список доступных провайдеров (фильтр по `currency`).
* `GET /v1/stats` — статистика использования (заголовки rate-limit).
* Проксирование запросов к History Service и Auth Service.

**Auth Service**\*\*\*\*

* Управление жизненным циклом API-ключей: создание, отзыв и валидация ключей.
* Делегирует хранение и проверку информации о платежах и квотах Billing Service.

4. **History Service**

   * Отвечает за запросы к истории курсов.
   * Читает данные из PostgreSQL и форматирует ответ.
5. **Billing Service**

   * Управление платёжными операциями (Stripe и др.).
   * Генерация счетов и отчётов по оплате.
6. **Monitoring & Metrics**

   * Сбор метрик (Prometheus) и логов (Loki/Sentry).
   * Дашборды и алерты в Grafana.

### 2.4. Эндпоинты по микросервисам

**Service-Fetcher**

* Автоматическое взаимодействие с внешними API — без публичных эндпоинтов.

**API Gateway**

* `GET /v1/rates` — список текущих курсов (параметры: `base`, `currencies[]`, `provider?`, `rateType?`).
* `GET /v1/rate` — курс одной валюты к другой (`from`, `to`, `provider?`, `rateType?`).
* `GET /v1/currencies` — список поддерживаемых валют и криптопар.
* `GET /v1/providers` — список доступных провайдеров (фильтр по `currency`).
* `GET /v1/stats` — статистика использования (заголовки rate-limit).
* Проксирование запросов к History Service и Auth Service.

**Auth Service**

* `POST /v1/auth/keys` — создать новый API-ключ.
* `GET /v1/auth/keys/{key}` — получить информацию о ключе.
* `DELETE /v1/auth/keys/{key}` — отозвать API-ключ.
* `GET /v1/auth/quotas` — получить квоты по API-ключу.

**History Service**

* `GET /v1/history` — исторические данные (параметры: `base`, `currencies[]`, `date`, `provider?`).
* `GET /v1/history/range` — диапазон дат (например, `startDate`, `endDate`).

**Billing Service**

* `POST /v1/billing/invoices` — создание счёта для клиента.
* `GET /v1/billing/invoices/{invoiceId}` — получение статуса счёта.
* `POST /v1/billing/payments` — фиксация оплаты счёта.
* `GET /v1/billing/usage` — отчёты по использованию и расходам.

**Monitoring & Metrics**

* `GET /metrics` — Prometheus-совместимый сбор метрик.
* Webhook-эндпоинты для алертов (Slack, email и т.д.).

## 3. Функциональные требования. Функциональные требования Функциональные требования

### 3.1. Эндпоинты для курсов и провайдеров

| №   | Эндпоинт          | Описание                                                                            |
| --- | ----------------- | ----------------------------------------------------------------------------------- |
| 3.1 | `GET /rates`      | Список курсов для набора валют:                                                     |
|     |                   | • Параметры запроса:                                                                |
|     |                   | – `base` (ISO-код исходной валюты)                                                  |
|     |                   | – `currencies[]` (массив ISO-кодов целевых валют)                                   |
|     |                   | – \`\` (код источника; необязательный)                                              |
|     |                   | – \`\` (тип курса MID/BUY/SELL; необязательный)                                     |
|     |                   | • Если `provider` не задан, применяется приоритет источников:                       |
|     |                   | – Фиат: CBR → MOEX → Сбер → ВТБ                                                     |
|     |                   | – Крипто: Binance → OKX → Kraken                                                    |
| 3.2 | `GET /rate`       | Курс одной валюты к другой:                                                         |
|     |                   | • Параметры:                                                                        |
|     |                   | – `from` (ISO-код, например USD)                                                    |
|     |                   | – `to` (ISO-код, например RUB)                                                      |
|     |                   | – \`\`                                                                              |
|     |                   | – \`\`                                                                              |
| 3.3 | `GET /history`    | История курса на дату:                                                              |
|     |                   | • Параметры:                                                                        |
|     |                   | – `base`, `currencies[]`, `date` (YYYY-MM-DD)                                       |
|     |                   | – \`\` (по умолчанию исторический источник ЦБ)                                      |
| 3.4 | `GET /currencies` | Список всех поддерживаемых валют и криптопар (метаданные без курсов).               |
| 3.5 | `GET /providers`  | Список доступных провайдеров; опциональный фильтр: `currency` (ISO-код).            |
| 3.6 | `POST /auth/keys` | Создание нового API-ключа.                                                          |
| 3.7 | `GET /stats`      | Статистика использования: общее число запросов, оставшиеся лимиты, дата последнего. |

**Авторизация и ключи**

* Клиент передаёт ключ в заголовке `X-API-Key`.
* Для каждого ключа хранится учёт запросов и лимитов.
* Эндпоинт для создания ключа: `POST /auth/keys`.

**Архитектура сервиса авторизации**

* Сервис реализован как отдельный микросервис (`Auth Service`) с собственным API для генерации, хранения и валидации API-ключей, управления тарифами и квотами.
* Интеграция с биллингом (Stripe и др.) происходит через API Billing Service.

**Rate-limit и квоты** и квоты\*\* и квоты\*\*

* Заголовки ответа: `X-RateLimit-Limit`, `X-RateLimit-Remaining`, `X-RateLimit-Reset`.

---

## 3.4. Примеры запросов и ответов

### Пример: GET /rates

**Запрос**:

```http
GET /v1/rates?base=USD&currencies=EUR,JPY&provider=MOEX&rateType=MID HTTP/1.1
Host: api.example.com
X-API-Key: YOUR_API_KEY
```

**Успешный ответ** (200 OK):

```json
{
  "status": "success",
  "data": {
    "base": "EUR",
    "history": [
      {"date": "2025-05-20", "rates": {"USD": 1.082}},
      {"date": "2025-05-19", "rates": {"USD": 1.078}}
    ],
    "provider": "CBR"
  }
}
```

**Успешный ответ** (200 OK):

```json
{
  "status": "success",
  "data": {
    "base": "EUR",
    "history": [
      {"date": "2025-05-20", "rates": {"USD": 1.082}},
      {"date": "2025-05-19", "rates": {"USD": 1.078}}
    ],
    "provider": "CBR"
  }
}
```

### Пример: GET /v1/currencies

**Запрос**:

```http
GET /v1/currencies HTTP/1.1
Host: api.example.com
X-API-Key: YOUR_API_KEY
```

**Успешный ответ** (200 OK):

````json
{
  "status": "success",
  "data": {
    "currencies": ["USD","EUR","RUB","BTC","ETH"]
  }
}
```http
GET /v1/currencies HTTP/1.1
Host: api.example.com
X-API-Key: YOUR_API_KEY
````

**Успешный ответ** (200 OK):

```json
{
  "status": "success",
  "data": {
    "currencies": ["USD","EUR","RUB","BTC","ETH"]
  }
}
```

### Пример: GET /providers

**Запрос**:

```http
GET /v1/providers?currency=RUB HTTP/1.1
Host: api.example.com
X-API-Key: YOUR_API_KEY
```

**Успешный ответ** (200 OK):

```json
{
  "status": "success",
  "data": {
    "currency": "RUB",
    "providers": ["CBR","MOEX","SBER","VTB"]
  }
}
```

---

## 3.2. Версионирование API

* Все эндпоинты должны быть версионированы через префикс в URL: `/v1/...`.
* При выпуске изменений, нарушающих обратную совместимость, создаётся новая мажорная версия (`/v2/...`).
* Минорные и патч-версии (`v1.1`, `v1.2` и т. д.) могут включать новые эндпоинты или расширение существующих без удаления полей.

## 3.3. Обработка ошибок и коды ответов

Общие принципы:

* \*\*Поле \*\*\`\`: указывает на результат запроса. Возможные значения:

  * `success` — запрос обработан успешно, тело ответа содержит нужные данные.
  * `error` — произошла ошибка, тело ответа содержит информацию об ошибке (код, сообщение).
* **HTTP-статус** в заголовке отвечает уровню ошибки (4xx для ошибок клиента, 5xx — сервера).

**Структура ответа при ошибке** (JSON):

```json
{
  "status": "error",
  "code": "<ERROR_CODE>",
  "message": "<Human-readable message>",
  "details": { /* необязательные дополнительные данные */ }
}
```

* \*\*Поле \*\*\`\` — внутренний код ошибки, определяемый сервисом. Примеры:

  * `INVALID_PROVIDER` — указанный провайдер не поддерживается.
  * `MISSING_API_KEY` — не передан API-ключ.
  * `RATE_LIMIT_EXCEEDED` — превышен лимит запросов.
  * `INVALID_DATE_FORMAT` — неверный формат даты.
* \*\*Поле \*\*\`\` — читаемое описание проблемы для разработчика.
* \*\*Поле \*\*\`\` — дополнительные данные (например, позволенные форматы).

**Структура успешного ответа** (JSON):

```json
{
  "status": "success",
  "data": { /* объект или массив с результатом */ }
}
```

* Поле `data` содержит payload с результатами вызова (курс, список валют и т.д.).

**Типовые коды ошибок**:

* `400 Bad Request` — некорректный запрос (например, неверный формат даты).

* `401 Unauthorized` — отсутствует или недействителен API-ключ.

* `403 Forbidden` — превышены лимиты или нет доступа к выбранному тарифу.

* `404 Not Found` — не найдены запрашиваемые валюты/провайдеры.

* `429 Too Many Requests` — превысился rate-limit.

* `500 Internal Server Error` — внутренняя ошибка сервиса.

* **Структура ответа при ошибке** (JSON):

  ```json
  {
    "status": "error",
    "code": "<ERROR_CODE>",
    "message": "<Human-readable message>",
    "details": { /* необязательные дополнительные данные */ }
  }
  ```

* **Типовые коды ошибок**:

  * `400 Bad Request` — некорректный запрос (например, неверный формат даты).
  * `401 Unauthorized` — отсутствует или недействителен API-ключ.
  * `403 Forbidden` — превышены лимиты или нет доступа к выбранному тарифу.
  * `404 Not Found` — не найдены запрашиваемые валюты/провайдеры.
  * `429 Too Many Requests` — превысился rate-limit.
  * `500 Internal Server Error` — внутренняя ошибка сервиса.

## 4. Нефункциональные требования

* **Производительность**: P95 latency < 200 мс для `GET /rates` при среднем трафике до 100 RPS.
* **Доступность**: SLA 99.9 %; автоматическое восстановление при сбоях.
* **Масштабируемость**: стартовый стек на Docker Compose с возможностью миграции в Kubernetes.
* **Безопасность**: HTTPS на всём трафике; WAF на уровне облака; валидация запросов; хранение секретов в AWS Secrets Manager или HashiCorp Vault.
* **Логирование и мониторинг**: Sentry для ошибок; Prometheus + Grafana для метрик или облачное решение (Datadog/New Relic) по мере роста.
* **Хранение логов**: Retention 14 дней; используйте Loki + Grafana или облачный агрегатор логов.

---

## 5. Интеграция с источниками курсов

* **Фиатные валюты (СНГ)**: CBR, Сбербанк, ВТБ, Московская биржа (MOEX).
* **Криптовалюты**: Binance, OKX, Kraken и др.
* **Частота обновления**:

  * Фиат: 1 раз в час или по расписанию ЦБ.
  * Крипто: каждые 1–5 минут.
* **Кеширование и хранение**:

  * Redis: TTL для актуальных данных (5 мин для крипто, 1 ч для фиата).
  * PostgreSQL: хранение истории за последний год (или дольше).

---

## 6. Пользовательские роли и биллинг

| Тариф      | Цена (USD/мес) | Лимиты запросов                                             | Описание                                |
| ---------- | -------------- | ----------------------------------------------------------- | --------------------------------------- |
| **Free**   | 0              | • 30 запросов в минуту• 100 в час• 1 000 в день             | Личное и тестовое использование.        |
| **Team**   | 49             | • 200 запросов в минуту• 1 000 в час• 10 000 в день         | Малые команды (до 5 пользователей).     |
| **Custom** | по запросу     | • До 10 000+ запросов в минуту• Специальные SLA и поддержка | Enterprise-решения, большие интеграции. |

---

## 7. Требования к среде исполнения и деплою

* **Хостинг**: VPS от Beget; один или несколько VPS для сервисов.
* **Инфраструктура баз данных**: PostgreSQL и Redis развёрнуты на отдельных VPS или через managed-сервисы Beget, при необходимости масштабируются вертикально/горизонтально.
* **Контейнеризация**: Docker Compose для локальной разработки и деплоя на VPS; контейнеры запускаются под supervision (systemd/docker-compose).
* **CI/CD**: GitHub Actions для lint, тестов, сборки Docker-образов и деплоя на VPS через SSH/Ansible.
* **Окружения**: dev (локально), staging (VPS staging), prod (VPS production).
* **Управление секретами**: переменные окружения в окружении VPS или HashiCorp Vault/Beget Secrets Manager.

---

## 8. Тестирование

* **Unit-тесты**: pytest + pytest-asyncio, покрытие \~80 % критических модулей.
* **Интеграционные тесты**: HTTPX + тестовый Docker Compose (PostgreSQL + Redis).
* **Нагрузочное тестирование**: k6 или locust для ключевых эндпоинтов, минимум раз в месяц.
* **CI**: автоматический прогон всех тестов и генерация отчёта покрытия.

---

## 9. Документация и поддержка

* **API-документация**: автоматически генерируется из спецификации OpenAPI (Swagger UI/Redoc).
* **User guide**: README с примерами `curl` и Python-клиента.
* **Поддержка**: канал в Slack; email [support@example.com](mailto:support@example.com).

---

## 10. План реализации и риски

* **Этапы**:

  1. Развёртывание микросервисной платформы (2 недели): Service-Fetcher, API Gateway, Auth Service, History Service, Billing Service, базовая настройка Redis и PostgreSQL.
  2. Реализация основных эндпоинтов (`/rate`, `/rates`, `/history`) + механизмы кеширования и валидации API-ключей (4 недели).
  3. Настройка биллинга, тарифов, мониторинга и алёртов, подготовка документации и поддержки (6 недель).
* **Риски**:

  * Зависимость от внешних API (отказы CBR/MOEX). **Меры**: fallback-провайдеры, повторные попытки, alerting.
  * Ограничения rate-limit у провайдеров. **Меры**: локальный кэш, очередь запросов, резервные источники.
  * Ограниченные ресурсы команды. **Меры**: фокус на начальной платформе, автоматизация CI/CD, повторное использование готовых решений.---

## 11. Service Level Agreement (SLA)

SLA (Service Level Agreement) — это соглашение с клиентом, определяющее минимальный уровень доступности и качества сервиса. Основные понятия:

* **Uptime** (время доступности) — процент времени, когда услуга работает корректно и отвечает на запросы.
* **Downtime** (время простоя) — суммарное время, когда сервис недоступен.
* **Порог SLA** 99.9% означает, что в течение месяца сервис может быть недоступен не более 0.1% времени (примерно 43.8 минуты).
* **Компенсации** — механизм возврата или кредита клиенту за нарушение SLA.

Далее основные параметры SLA для нашего API:

* **Уровень доступности**: 99.9% uptime (не более 43.8 минут недоступности в месяц).
* **Метрики мониторинга**: availability, error rate, latency.
* **Пороговые значения**:

  * Latency P95 < 200 мс
  * Error rate < 1%
* **Компенсации**: кредит за следующий месяц при просадке SLA: 10% за каждый 0.1% ниже 99.9%, максимум 50%.
* **Процедура эскалации**:

  1. Клиент сообщает о проблеме в поддержку (Slack/email).
  2. Инженерная команда проводит triage в течение 1 часа.
  3. Эскалация к CTO при невосстановлении within 4 часов.---

## 12. Юридические и коммерческие аспекты

* **Terms of Service**: проектируется на основе стандартных соглашений. Включает положения об ответственности, ограничениях и правах сторон.
* **Privacy Policy**: соответствует GDPR и локальным законам о персональных данных. Хранение и удаление логов по запросу.
* **Политика возвратов**: кредит за неоказанную услугу при нарушении SLA.
* **Юридический адрес и контактная информация**: добавляется в финальную версию.
